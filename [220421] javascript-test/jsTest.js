// let nuri = "이누리";
// let text = "을(를) 좋아합니다.";

// let foodObject = { // 객체가 생겨난 이유
//   sushi: "초밥",
//   snack: "과자",
//   coffee: "커피"
// }
// 알고리즘, 프로그래밍을 하기에 따라서 객체/배열/변수를 얼마든지 바꿔서 써도 된다.
/*
* 자료 구조
변수에 이름을 지어줄 때 (작명할 때) ==> "데이터타입"을 살짝 표시해주는 버릇을 가지면 이 변수가 어떤 데이터 타입인지 찾을 필요가 없다.
ex) food라는 변수는 object타입이다 ==> foodObject라고 작명해준다.
==> "nuri라는 변수는 foodObject라는 객체의 무언가를 가져다 쓰겠지" 라고 추측할 수 있게 된다.
* 값이 별로 중요해지지 않는다.
* 타입이 중요하다.
*/


// let stringSum = `${nuri}씨는 ${food.snack}${text}`;
// 변수 stringSum이라는 녀석은 nuri라는 변수와 text라는 변수를 앞뒤로 합쳤다. ==> 를 stringSum이라는 변수에 대입했다.
// console.log(stringSum);

// console.log(food);


// let pokemon = ["이상해씨", "이상해풀", "이상해꽃", "파이리", "리자드", "리자몽"];
// // 배열(array)에는 원소(요소 element), length값이 6인 데이터를 변수 pokemon에 대입했다.

// console.log(pokemon);
// console.log(pokemon.length); 
// // 배열의 키 값 중에 길이값을 가져오는 length라는 프로퍼티를 접근했다. (==getter 역할/속성)
// console.log(pokemon[3]);
// // '파이리'의 인덱스 값은 '3'
// console.log(pokemon[pokemon.length-1]);
// // '마지막 원소를 불러오고 싶다' ==> 길이값의 -1은 무조건 마지막 원소이다.
// let three = 3;
// console.log(pokemon[three]);

// let max = `${pokemon[0]} 포켓몬의 최종진화는 ${pokemon[0+2]}`;

// console.log(max);

